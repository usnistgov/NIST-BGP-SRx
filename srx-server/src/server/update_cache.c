/**
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of
 * their official duties. Pursuant to title 17 Section 105 of the United
 * States Code this software is not subject to copyright protection and
 * is in the public domain.
 *
 * NIST assumes no responsibility whatsoever for its use by other parties,
 * and makes no guarantees, expressed or implied, about its quality,
 * reliability, or any other characteristic.
 *
 * We would appreciate acknowledgment if the software is used.
 *
 * NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
 * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
 * FROM THE USE OF THIS SOFTWARE.
 *
 *
 * This software might use libraries that are under GNU public license or
 * other licenses. Please refer to the licenses of all libraries required
 * by this software.
 *
 * The update cache holds the updates in two separate structures, one is the
 * update cache, a hash table with the update id as key and the update as
 * value. The other is a list, that allows to scan through all updates. Both
 * MUST be maintained the same.
 *
 * @version 0.5.0.0
 *
 * Changelog:
 * -----------------------------------------------------------------------------
 * 0.5.0.0  - 2017/07/11 - kyehwanl
 *            * Fixed BZ1190 - added missing initialization for cEntry->pathData
 *          - 2017/07/08 - oborchert
 *            * Fixed issue with BGPsec results in modifyUpdateResult.
 *          - 2017/07/07 - oborchert
 *            * Renamed getUpdateData into getUpdateStats
 *            * Replaced the CacheEntry::blob and CacheEntry::blob_length with
 *              CacheEntry::pathData which contains both representations of
 *              AS list and BGPsec_PATH attribute.
 *          - 2017/07/06 - oborchert
 *            * Modified function modifyUpdateResult and added parameter
 *              suppressNotification which allows to suppress sending update
 *              notifications being send when the update value changes.
 *            * Used VRT_... values where appropriate
 *          - 2017/07/05 - oborchert
 *            * Function createUpdateCache had a wrong parameter which was also
 *              replaced inside the function with a define value. Fixed that.
 *              Correct parameter name 'minNumberOfClients'
 *          - 2017/06/30 - oborchert
 *            * Added ski_cache registration if the given update contains the
 *              BGPSEC portion. - Added code to functions storeUpdate and
 *              deleteUpdateFromCache
 * 0.4.0.1  - 2016/07/02 - oborchert
 *            * Removed misleading error message. The system generated an error
 *              for each update that could not be stored a second time.
 *              Duplicates will not be stored - correct behavior and therefore I
 *              removed the misleading message.
 * 0.4.0.0  - 2016/06/19 - oborchert
 *            * Updated the collisionDetection method to conform with the
 *              algorithm within the id generation.
 * 0.3.0.10 - 2015/11/09 - oborchert
 *            * Removed types.h
 *            * Removed unused variables.
 * 0.3.0    - 2012/12/31 - oborchert
 *            * Added XML print function
 *          - 2012/12/17 - oborchert
 *            * Changed the logic of function getUpdateResult's signature. Both,
 *              result and default value are out parameters now.
 * 0.2.0    - 2011/11/01 - oborchert
 *            * mostly rewritten
 * 0.1.0    - 2010/04/15 - pgleichm
 *            * Code created.
 */

#include <uthash.h>
#include <stdbool.h>
#include <stdint.h>
#include <malloc.h>
#include <time.h>
#include <srx/srxcryptoapi.h>
#include "server/update_cache.h"
#include "server/server_connection_handler.h"
#include "server/prefix_cache.h"
#include "server/ski_cache.h"
#include "shared/srx_defs.h"
#include "shared/srx_packets.h"
#include "util/log.h"
#include "util/prefix.h"
#include "util/xml_out.h"
#include "util/mutex.h"
#include "main.h"

/* Number of preallocated result slots */
//#define NUM_PREALLOC  20
#define NUM_PREALLOC  1

#define HDR "([0x%08X] UpdateCache): "

/**
 * A single update result.
 */
typedef struct {
  uint8_t* clients;           // clients with value 0 are unused.
  uint8_t  noPossibleClients; // maximum number of clients in list without
                              // extending

  SRxUpdateID      updateID;  // the unique update ID.

  UT_hash_handle   hh;            // The hash table where this entry is stored
                                  // in
  uint32_t         asn;           // The Origin AS of this update
  IPPrefix         prefix;        // The prefix of this update
  SRxResult        srxResult;     // The result generated by SRx
  SRxDefaultResult defaultResult; // The result provided by verification
                                  // request.
  uint32_t         roaRefCount;   // the number of ROA's that cover this update

  uint16_t         gcFlag;        // Indicates when this entry can be deleted
                                  // by the garbage collector.

  UC_UpdateData    pathData;      // This element replaces the blob.
  uint32_t         aspathCacheID; // aspath cache key ID
} CacheEntry;

// Forward declarations
bool _addClientReference(UpdateCache* self, CacheEntry* cEntry,
                         uint8_t clientID, ProxyClientMapping* clientMapping);
uint16_t getGCTime(uint16_t keepTime);

/**
 * Clean up the cache data element.
 *
 * @param data The cache data element.
 *
 * @since 0.5.0.0
 */
static void _cleanCachPathData(CacheEntry* cEntry)
{
  UC_UpdateData* data = &cEntry->pathData;

  if (data->asn_path != NULL)
  {
    free(data->asn_path);
  }
  if (data->bgpsec_path != NULL)
  {
    free(data->bgpsec_path);
  }
  memset(data, 0, sizeof(UC_UpdateData));
}

/**
 * This function selects the data from bgpsecData that is used for ID generation
 * - see srx_identifier::generateIdentifier and stores it in the cache entry.
 * It is important that both data blobs are same otherwise problems with the
 * ID finding are given.
 * This method copies the data from bgpsecData into the cache entry. Therefore
 * the memory allocated in bgpsecData can safely be deallocated.
 *
 * @param cEntry The cache entry where the blob data will be stored in.
 * @param bgpData The BGPsec / BGP4 data that has to be stored.
 * @param prefix The prefix of the update (in network order)
 *               (MUST NOT BE NULL FOR BGPSEC)
 *
 * @return false if the cache entry already contains data,otherwise true.
 *
 * @since 0.4.0.0
 *
 * @see srx_identifier.h::generateIdentifier
 */
bool storeCacheEntryBlob(CacheEntry* cEntry, BGPSecData* bgpData,
                         IPPrefix* prefix)
{
  bool retVal  = false;
  int  dataLen = 0;
  if (cEntry != NULL)
  {
    UC_UpdateData* data = &cEntry->pathData;
    // First check if cEntry is ready for new data
    if ((data->asn_path == NULL) && (data->bgpsec_path == NULL))
    {
      retVal = true;
      memset (&data->nlri, 0, sizeof(SCA_Prefix));

      data->myAS = bgpData->local_as;
      if (prefix != NULL)
      { // Needed for BGPsec
        data->nlri.afi    = bgpData->afi;
        data->nlri.safi   = bgpData->safi;
        data->nlri.length = prefix->length;
        if (prefix->ip.version == 4)
        {
          int size = sizeof(struct in_addr);
          memcpy(&data->nlri.addr.ipV4, &prefix->ip.addr.v4.in_addr, size);
        }
        else
        {
          int size = sizeof(struct in6_addr);
          memcpy(&data->nlri.addr.ipV6, &prefix->ip.addr.v6.in_addr, size);
        }
      }

      // Copy AS path (list of AS numbers)
      if (bgpData->numberHops > 0)
      {
        data->hops = bgpData->numberHops;
        dataLen = bgpData->numberHops * 4;
        data->asn_path = malloc(dataLen);
        memcpy(data->asn_path, bgpData->asPath, dataLen);
      }

      // Copy BGPsec path (BGPsec_PATH attribute)
      if (bgpData->attr_length != 0)
      {
        data->length      = bgpData->attr_length;
        data->bgpsec_path = malloc(bgpData->attr_length);
        memcpy(data->bgpsec_path, bgpData->bgpsec_path_attr,
               bgpData->attr_length);
      }
    }
  }

  return retVal;
}

/*---------------------
 * Hash-table functions
 *
 * @note Uses R/W lock
 */
/**
 * This method searches the cache for the update with the given update id.
 * if found the result is written into the out pointer.
 *
 * @param self The reference for the update cache
 * @param updateID The update ID to search for.
 * @param out the cache entry containing the update in case it was found.
 *
 * @return true if the update was found, otherwise false.
 */
static bool tableFind(UpdateCache* self, SRxUpdateID updateID, CacheEntry** out)
{
  acquireReadLock(&self->tableLock);
  HASH_FIND(hh, (CacheEntry*)self->table, &updateID, sizeof(SRxUpdateID),
            (*out));
  unlockReadLock(&self->tableLock);

  return (*out != NULL);
}

/**
 * Add the update encapsulated in the cache entry element into the cache. The
 * key is the updateID and the value is the cache entry containing the update
 * information.
 *
 * @param self the update cache.
 * @param cEntry the update to be stored.
 */
static void tableAdd(UpdateCache* self, CacheEntry* cEntry)
{
  acquireWriteLock(&self->tableLock);
  HASH_ADD(hh, *((CacheEntry**)&self->table), updateID, sizeof(SRxUpdateID),
           cEntry);
  unlockWriteLock(&self->tableLock);
}

/**
 * Remove the update entry from the update cache. This method does NOT release
 * the memory attached to the cache entry!!!
 *
 * @param self The update cache.
 * @param cEntry the entry containing the update information.
 */
static void tableDel(UpdateCache* self, CacheEntry* cEntry)
{
  acquireWriteLock(&self->tableLock);
  HASH_DEL(*((CacheEntry**)&self->table), cEntry);
  unlockWriteLock(&self->tableLock);
}

/*--------
 * Exports
 */

/**
 * Initialized the update cache. The memory for the cache MUST be allocated
 * by the caller of this method.
 *
 * @param self The update cache
 * @param chCallback The callback method executed for changes within the cache
 * @param minNumberOfClients the minimum number of expected clients. Must be
 *                           greater then 0;
 *
 * @return true = successfully initialized, false = an error occurred
 */
bool createUpdateCache(UpdateCache* self, UpdateResultChanged chCallback,
                       uint8_t minNumberOfClients, Configuration* sysConfig)
{
  if (!initMutex(&self->itemMutex))
  {
    RAISE_ERROR("Unable to setup the item Mutex");
    return false;
  }
  if (!createRWLock(&self->tableLock))
  {
    RAISE_ERROR("Unable to setup the hash table r/w lock");
    releaseMutex(&self->itemMutex);
    return false;
  }

  self->resChangedCallback = chCallback;
  // By default keep the hashtable null, it will be initialized with the first
  // element that will be added.
  self->table = NULL;
  self->itemsUsed = NUM_PREALLOC;
  self->minNumberOfClients = minNumberOfClients;
  self->lockedClients = malloc(MAX_PROXY_CLIENT_ELEMENTS);
  memset(self->lockedClients, false, MAX_PROXY_CLIENT_ELEMENTS);

  self->sysConfig = sysConfig;

  initSList(&self->allItems);

  return true;
}

//TODO: Documentation
void releaseUpdateCache(UpdateCache* self)
{
  RAISE_ERROR("Release Update Cache also should empty the cache first!");
  if (self != NULL)
  {
    releaseRWLock(&self->tableLock);
    releaseMutex(&self->itemMutex);

    // Empty cache first
    emptyUpdateCache(self);
    free(self->lockedClients);
    releaseSList(&self->allItems);
  }
}

/**
 * Queries the update cache for the result associated with the update. This
 * method DOES NOT create a cache entry if no update was found. This method DOES
 * NOT change the update cache in any means. If already stored updates contain
 * SRx_RESULT_UNDEFINED as roa or bgpsec result, this result will be exchanged
 * with the default value.
 *
 * @param self The instance of the update cache
 * @param updId The update ID whose result is queried
 * @param clientID The id of the client that requests the update result.
 *                 in case the ID is greater than zero "> 0" the client will be
 *                 registered with the update, Otherwise it will not be
 *                 registered.
 * @param client   The proxy client. MUST be NULL if clientID == 0.
 * @param srxRes The current result associated with the update This is an OUT
 *               parameter.
 * @param defResult The default result provided by proxy during verification
 *                  call. This is an OUT parameter.
 *
 * @return true if the update was found, false if not.
 */
bool getUpdateResult(UpdateCache* self, SRxUpdateID* updateID,
                     uint8_t clientID, void* clientMapping,
                     SRxResult* srxRes, SRxDefaultResult* defaultRes, uint32_t *pathId)
{
  // The cache entry also need the addition of source and predefined result.
  CacheEntry* cEntry = NULL;
  // By default declare the update as not found
  bool retVal = false;
  // This seems to be silly at this point but it might be that the id will
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  // Look for the update
  if (tableFind(self, updID, &cEntry))
  {
    // Prefix Origin values
    srxRes->roaResult               = cEntry->srxResult.roaResult;
    defaultRes->resSourceROA        = cEntry->defaultResult.resSourceROA;
    defaultRes->result.roaResult    = cEntry->defaultResult.result.roaResult;

    // Path Validation values
    srxRes->bgpsecResult            = cEntry->srxResult.bgpsecResult;
    defaultRes->resSourceBGPSEC     = cEntry->defaultResult.resSourceBGPSEC;
    defaultRes->result.bgpsecResult = cEntry->defaultResult.result.bgpsecResult;

    // ASPA Validation Result
    srxRes->aspaResult            = cEntry->srxResult.aspaResult;
    defaultRes->resSourceASPA     = cEntry->defaultResult.resSourceASPA;
    defaultRes->result.aspaResult = cEntry->defaultResult.result.aspaResult;

    if (pathId != NULL)
      *pathId = cEntry->aspathCacheID; 

    if (clientID > 0)
    {
      // Register the update with the client!
      _addClientReference(self, cEntry, clientID,
                          (ProxyClientMapping*)clientMapping);
    }

    retVal = true;
  }
  else
  {
    srxRes->roaResult               = SRx_RESULT_UNDEFINED;
    defaultRes->resSourceROA        = SRxRS_DONOTUSE;
    defaultRes->result.roaResult    = SRx_RESULT_DONOTUSE;

    // Path Validation values
    srxRes->bgpsecResult            = SRx_RESULT_UNDEFINED;
    defaultRes->resSourceBGPSEC     = SRxRS_DONOTUSE;
    defaultRes->result.bgpsecResult = SRx_RESULT_DONOTUSE;

    // ASPA Validation Values
    srxRes->aspaResult            = SRx_RESULT_UNDEFINED;
    defaultRes->resSourceASPA     = SRxRS_DONOTUSE;
    defaultRes->result.aspaResult = SRx_RESULT_DONOTUSE;
  }

  return retVal;
}

/**
 * Assign the given client to the cache entry. This method extends the memory
 * if needed.
 *
 * @param cEntry The cache entry containing the update
 * @param clientID The client assigned to the update.
 *
 * @return true if the client is attached!
 */
bool _addClientReference(UpdateCache* self, CacheEntry* cEntry,
                         uint8_t clientID, ProxyClientMapping* clientMapping)
{
  bool added = false;
  int idx;

  if (clientID == 0)
  {
    RAISE_SYS_ERROR("Invalid client ID %d added to the Update Cache for Update"
                    "[0x%08X]!!!", clientID, cEntry->updateID);
  }

  // Try to find then ext empty spot.
  for (idx = 0; idx < cEntry->noPossibleClients; idx++)
  {
    if (cEntry->clients[idx]==0)
    {
      cEntry->clients[idx] = clientID;
      //TODO: depending on the final GC implementation if the GC uses a delete
      //      list, remove this cEntry from there in case gcFlag > 0
      // Increase the update count of this client
      clientMapping->updateCount++;
      added = true;
      break;
    }
    else if (cEntry->clients[idx]==clientID)
    {
      added = true;
      break;
    }
  }

  if (added)
  {
    cEntry->gcFlag       = 0; // Reset the GC flag
  }
  else
  { // run out of memory, increase the array list
    // TODO: Maybe set a counter flag in UpdateCahce. this flag
    // could be used to automatically increase the minimum number of clients
    // by 2 or the default value for future updates. A minimum threshold could
    // be 1000 extensions or even configured?

    int newSize = cEntry->noPossibleClients + self->minNumberOfClients;
    cEntry->clients = realloc(cEntry->clients, newSize);

    if (cEntry->clients)
    {
      for (idx = cEntry->noPossibleClients; idx < newSize; idx++)
      { // initialize with zero "0"
        cEntry->clients[idx] = (uint8_t)0;
      }
      // Now add the new client
      cEntry->clients[cEntry->noPossibleClients] = clientID;
      cEntry->noPossibleClients = (uint8_t)newSize;
      added = true;
    }
    else
    {
      RAISE_SYS_ERROR("Extending client memory for Update[0x%08X] failed!!",
                      cEntry->updateID);
    }
  }

  return added;
}

/**
 * Stores an update in the update cache. This method returns 0 in case the
 * update already exists in the update cache. In this case depending on the
 * operational flow the stored update should be re-queried. This might happen
 * if two clients request the same update information at the exact same time
 * and both will receive information that the update is not stored yet. In this
 * case both might attempt to store the update. Here it is important to notice
 * that the default value might differ. The caller where the result is 0 should
 * re-query the result to assure the returned validation result is same.
 * In case the result value is 1 the provided update was stored successfully.
 * for internal errors the result value is -1. For the update result the value
 * SRX_RESULT_UNDEFINED is used to indicate that the validation was not
 * performed yet. As long as the value is UNDEFINED the command handler accepts
 * a validation request for this particular update. Once the value is other than
 * "UNDEFINED" a validation attempt will be stopped. From this moment the RPKI-
 * Handler and BGPSEC-handler are the only two instances that can start a new
 * validation.
 * If the Update includes a BGPsec blob, this function will register the update
 * with the SKI cache.
 *
 *
 * @param self The instance of the update cache.
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 * @param clientMapping The mapping entry for the client.
 * @param updateID The ID of the Update.
 * @param prefix The prefix of the update.
 * @param asn    The AS number of the update.
 * @param defRes The default result info. This will only be taken when stored
 *               the very first time. In case the value is NULL for a first time
 *               storage, the internal UNDEFINED and UNKNOWN will be used.
 * @param bgpData Contains BGP / BGPsec data. This parameter as well as defRes
 *               is only used during initial storing of an update. (CAN BE NULL)
 *
 *
 * @return 1 the result stored, 0 the update is already stored,
 *         -1 indicates an internal error
 */
int storeUpdate(UpdateCache* self, uint8_t clientID, void* clientMapping,
                SRxUpdateID* updateID, IPPrefix* prefix, uint32_t asn,
                SRxDefaultResult* defRes, BGPSecData* bgpData, uint32_t pathId)
{
  CacheEntry* cEntry;

  int retVal = 1; // by default report it worked

  // This seems to be silly at this point but it might be that the id will
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  LOG(LEVEL_DEBUG, HDR "Store update [ID:0x%08X] in update cache.",
                   pthread_self(), updID);

  // Existing entry then only update the result values.
  if (tableFind(self, updID, &cEntry))
  {
    LOG(LEVEL_WARNING, "Attempt to store an update that already exists in "
                       "update cache!");
    retVal = 0;
  }
  else
  {
    // The update will be stored in two phases, first it will be stored in the
    // update list that is accessible from outside. The the update information
    // will be stored in the hash table.

    // Store a brand new update in the list
    // New entry
    lockMutex(&self->itemMutex);

    if (self->itemsUsed == NUM_PREALLOC)
    {
      // In case the pre-allocated empty space is used up, create more.
      self->availItems = appendToSList(&self->allItems,
                                       sizeof(CacheEntry) * NUM_PREALLOC);
      if (self->availItems == NULL)
      {
        return -1;
      }
      self->itemsUsed = 0;
    }

    // now get the new accessible space.
    cEntry = (CacheEntry*)(self->availItems
                           + (self->itemsUsed * sizeof(CacheEntry)));
    // mark the entry as used for now.
    self->itemsUsed++;

  //    unlockMutex(&self->itemMutex);

    cEntry->updateID      = updID;
    cEntry->asn           = asn;
    cEntry->aspathCacheID = pathId;
    cpyPrefix(&cEntry->prefix, prefix);
    cEntry->srxResult.bgpsecResult = SRx_RESULT_UNDEFINED;
    cEntry->srxResult.roaResult    = SRx_RESULT_UNDEFINED;
    cEntry->srxResult.aspaResult   = SRx_RESULT_UNDEFINED;

    if (defRes != NULL)
    {
      cEntry->defaultResult.result.roaResult    = defRes->result.roaResult;
      cEntry->defaultResult.result.bgpsecResult = defRes->result.bgpsecResult;
      cEntry->defaultResult.result.aspaResult   = defRes->result.aspaResult;
      cEntry->defaultResult.resSourceROA        = defRes->resSourceROA;
      cEntry->defaultResult.resSourceBGPSEC     = defRes->resSourceBGPSEC;
      cEntry->defaultResult.resSourceASPA       = defRes->resSourceASPA;
    }
    else
    {
      cEntry->defaultResult.result.roaResult    = SRx_RESULT_UNDEFINED;
      cEntry->defaultResult.result.bgpsecResult = SRx_RESULT_UNDEFINED;
      cEntry->defaultResult.result.aspaResult   = SRx_RESULT_UNDEFINED;
      cEntry->defaultResult.resSourceROA        = SRxRS_UNKNOWN;
      cEntry->defaultResult.resSourceBGPSEC     = SRxRS_UNKNOWN;
      cEntry->defaultResult.resSourceASPA       = SRxRS_UNKNOWN;
    }
    // Other Update relates data
    // BGPSEC
    if (bgpData != NULL)
    {
      memset(&cEntry->pathData, 0x00,  sizeof(UC_UpdateData));
      //TODO: see BZ197 - this causes once a while a SEGDEV
      // Maybe not anymore, completely rewritten in 0.5.0.0
      if (storeCacheEntryBlob(cEntry, bgpData, prefix))
      {
        // Now register the update and SKIs with the SKI CACHE
        SKI_CACHE* sCache = getSKICache();
        ski_registerUpdate(sCache, &cEntry->updateID,
                           (SCA_BGP_PathAttribute*)bgpData->bgpsec_path_attr);
      }
      // else the element exists already in the cache.
      // It is not an error. BZ 1010
      // in this case we do not need to register the update with the ski cache.
      // it is already in
    }
    else
    {
      // If this here throws a SEGDEV then it is time to replace the SList
      // implementation
      UC_UpdateData* data = &cEntry->pathData;
      if (data->bgpsec_path != NULL)
      {
        free(data->bgpsec_path);
      }
      if (data->asn_path != NULL)
      {
        free(data->asn_path);
      }
      memset(data, 0, sizeof(UC_UpdateData));
    }

    // Add the client ID to the update
    int memsize = sizeof(uint8_t) * self->minNumberOfClients;
    cEntry->clients = malloc(memsize);
    memset(cEntry->clients, 0, memsize);
    cEntry->noPossibleClients = self->minNumberOfClients;

    // ClientID might be zero "0" is the request is store only - This should not
    // be the norm. updates with zero clients will be subject to garbage
    // collection after a while.
    if (clientID > 0)
    {
      if (!_addClientReference(self, cEntry,
                               clientID, (ProxyClientMapping*)clientMapping))
      {
        retVal = -1;
        RAISE_SYS_ERROR("ERROR assigning client to update!!!");
        // TODO: maybe remove the entry from the list!!!
      }
    }
    else
    {
      // Mark for GC
      uint16_t keepWindow = (uint16_t)self->sysConfig->defaultKeepWindow;
      cEntry->gcFlag = getGCTime(keepWindow);
    }

    // Finally add the entry to cache.
    tableAdd(self, cEntry);

    unlockMutex(&self->itemMutex);
  }
  return retVal;
}

/**
 * Stores a result for in the update cache for later retrieval. If this
 * overwrites an existing update result, then the registered
 * UpdateResultChanged callback is called. The update MUST exist!
 * Only result values other than SRx_RESULT_DONOTUSE are used. This allows to
 * change a single value only.
 *
 * Since Version 0.5.0.0: The parameter dontNotify allows to suppress calling
 * the UpdateResultChanged callback function. This is used during cache updates
 * when ROAS are added and removed. In this case the update might change its
 * validation status multiple times and can cause unnecessary churn in the
 * system. Processing the EndOfData PDU or the router to cache protocol will
 * take care of sending the notification to the routers.
 *
 * @param self The instance of the update cache.
 * @param updateID The ID of the Update.
 * @param result the result the current update has to be updated with. In case
 *               the result differs from the stored update result, a
 *               notification will be send to the client. to indicate which
 *               result MUST NOT be modified use SRx_RESULT_DONOTUSE.
 * @param suppressNotification in case this flag is 'true' do not send a
 *               notification to the clients (routers).
 *
 * @return true the result stored, false indicates an internal error such as the
 *              update does not exist.
 */
bool modifyUpdateResult(UpdateCache* self, SRxUpdateID* updateID,
                        SRxResult* result, bool suppressNotification)
{
  CacheEntry* cEntry;
  bool retVal = true;
  // This seems to be silly at this point but it might be that the id will
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  // Existing entry then only update the result values.
  if (!tableFind(self, updID, &cEntry))
  {
    RAISE_SYS_ERROR("Does not exist in update cache, can not modify it!");
    retVal = false;
  }
  else
  {
    lockMutex(&self->itemMutex);

    SRxValidationResult valRes;
    valRes.updateID = updID;
    valRes.valType  = VRT_NONE;
    valRes.valResult.roaResult    = cEntry->srxResult.roaResult;
    valRes.valResult.bgpsecResult = cEntry->srxResult.bgpsecResult;
    valRes.valResult.aspaResult   = cEntry->srxResult.aspaResult;
    //valRes.clientID		  = cEntry->clientID;

    // Check if ROA results can be used.
    if (result->roaResult != SRx_RESULT_DONOTUSE)
    { // // Do ROA results differ ?
      if (result->roaResult != cEntry->srxResult.roaResult)
      {
        valRes.valType |= VRT_ROA;
        cEntry->srxResult.roaResult = result->roaResult;
        valRes.valResult.roaResult = result->roaResult;
      }
    }

    // Check if BGPSEC results can be used.
    if (result->bgpsecResult != SRx_RESULT_DONOTUSE)
    { // Check for changes in bgpsec result
      if (result->bgpsecResult != cEntry->srxResult.bgpsecResult)
      {
        valRes.valType |= VRT_BGPSEC;
        cEntry->srxResult.bgpsecResult = result->bgpsecResult;
        valRes.valResult.bgpsecResult = result->bgpsecResult;
      }
    }

    // Check if ASPA results can be used.
    if (result->aspaResult != SRx_RESULT_DONOTUSE)
    { 
      valRes.valType |= VRT_ASPA;
      valRes.valResult.aspaResult = result->aspaResult;

      if (result->aspaResult != cEntry->srxResult.aspaResult)
      {
        cEntry->srxResult.aspaResult = result->aspaResult;
      }
    }


    // check if a validation result changed.
    if (!suppressNotification && (valRes.valType != VRT_NONE))
    {
      if (self->resChangedCallback != NULL)
      {
        // Notify of the change of validation result.(call handleUpdateResultChange)
        self->resChangedCallback(&valRes);
      }
      else
      {
        RAISE_ERROR("No resChangedCallback function registered! "
                    "Cannot propagate the changes in the validation result!");
        retVal = false;
      }
    }

    unlockMutex(&self->itemMutex);
  }

  return retVal;
}

bool modifyUpdateCacheResultWithAspaVal(UpdateCache* self, SRxUpdateID* updateID,
                        SRxResult* srxResult_aspa)
{

  CacheEntry* cEntry;
  bool retVal = false;
  SRxUpdateID updID = *updateID;

  if (!tableFind(self, updID, &cEntry))
  {
    RAISE_SYS_ERROR("Does not exist in update cache, can not modify aspa result!");
    retVal = false;
  }
  else
  {
    lockMutex(&self->itemMutex);

    // Check if ASPA srxResult_aspas can be used.
    if (srxResult_aspa->aspaResult != SRx_RESULT_DONOTUSE)
    { // Check for changes in bgpsec srxResult_aspa
      if (srxResult_aspa->aspaResult != cEntry->srxResult.aspaResult)
      {
        cEntry->srxResult.aspaResult = srxResult_aspa->aspaResult;
        LOG(LEVEL_INFO, "\033[92m""cEntry(UpdateCache) updated with uID: %08X, ASPA result:%d ""\033[0m", 
            *updateID, srxResult_aspa->aspaResult);
        retVal = true;
      }
    }

    unlockMutex(&self->itemMutex);
  }
  return retVal;
}

/**
 * Try to finally delete the update.
 *
 * @param self The Update cache
 * @param cEntry The cache entry (update)
 * @param pCache The prefix cache.
 * @param force  Force the deletion of the update. This ignores if the update is
 *               still referenced by clients.
 *
 * @return true if the update was deleted, otherwise false/
 *
 * @since 0.3.0
 */
bool gcTestAndDeleteUpdate(UpdateCache* self, CacheEntry* cEntry,
                           void* pCache, bool force)
{
  //TODO: Test one last time if the update can be deleted. If so then delete it.
  // This method MUST be called by the garbage collector.
  LOG(LEVEL_INFO,"IMPLEMENTATION CAN BE EXPECTED WITH VERSION 0.4");
  bool delete = !force;

  if (!force)
  {
    // 1. CHECK IF GC TIME IS READY

    // 2. CHECK ONE MORE TIME IF NO REFERENCE EXISTS
  }

  if (delete)
  {
    if (!removeUpdate((PrefixCache*)pCache, &cEntry->updateID, &cEntry->prefix,
                      cEntry->asn))
    {
      // The reason might be that the update was not validated. (stored only)
      LOG(LEVEL_WARNING, "Could not delete the update 0x08X from the prefix "
                         "cache!");
    }

    // now remove it from the update cache
    // Does not release the memory but only removes the hash table entry
    tableDel(self, cEntry);
    // Now remove it from the allItems list of the cache
    deleteFromSList(&self->allItems, cEntry);

    // Free the memory of the bgpsec blob;
    _cleanCachPathData(cEntry);
    // Free the cache entry.
    free(cEntry);
  }

  return delete;
}

/**
 * Set the flag when the update can be garbage collected.
 *
 * @param cEntry The cache entry - update
 * @param timeOfDeletion The GC time when the update can be deleted.
 */
void setGCFlag(CacheEntry* cEntry, uint16_t timeOfDeletion)
{
  cEntry->gcFlag = timeOfDeletion;
}

/**
 * Calculates a new GC time when to run.
 *
 * @param keepTime The proposed time to wait
 *
 * @return the next time the GC can run. Notice that this timestamp is a 16 bit,
 *         NOT 32 bit number. The Garbage collector knows how to deal with
 *         overflows
 */
uint16_t getGCTime(uint16_t keepTime)
{
  time_t nextRealTime = time(NULL) + keepTime;
  return (uint16_t)(nextRealTime);
}

/**
 * Removes the given client update reference. This method DOES NOT delete
 * the physical instance of the update, it sets the deletion flag for the
 * garbage collector if no further reference exists.
 *
 * @param entry the update entry within the update cache
 * @param the client that has to be removed
 *
 * @return 0 if no further references exist, 1 for one or more existing
 *         references, -1 no reference between client and update found!
 */
int _deleteUpdateFromCache_clientMgmt(CacheEntry* entry, uint8_t clientID)
{
  int idx;
  bool found  = false;
  bool others = false;

  for (idx = 0; idx < entry->noPossibleClients; idx++)
  {
    if (entry->clients[idx] == clientID)
    {
      found = true;
      entry->clients[idx] = (uint8_t)0;
    }
    else if(entry->clients[idx] != 0)
    {
      others = true;
      if (found)
      {
        // Move all clients one to the left
        if (entry->clients[idx] != 0)
        {
          entry->clients[idx-1] = entry->clients[idx];
          entry->clients[idx] = 0;
        }
        else
        {
          // can stop here
          break;
        }
      }
    }
  }

  return !found ? -1 : others ? 1 : 0;
}

/**
 * Removes the update data from the list and releases all memory associated to
 * it.
 *
 * @note This method ONLY deletes the update from the update cache. It is
 *       important to assure that other references such as the prefix_cache
 *       might be affected by this.
 *
 * @param self The instance of the update cache
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 *                 If this id is zero all mappings and the update itself will be
 *                 removed!
 * @param cEntry   The update itself.
 * @param timeOfDeletion A proposed real-time in seconds until the update should
 *                 be kept before final deletion. The cache might remove the
 *                 update at any other time though.
 *
 * @return true If the update / association could be removed, false if the
 *              update was not either found in the cache or no association to
 *              the client was found.
 */
int _deleteUpdateFromCache(UpdateCache* self, uint8_t clientID,
                           CacheEntry*  cEntry, uint16_t timeOfDeletion)
{
  bool retVal = false;

  // Check if the entry is associated with the client that requests the
  // deletion.
  switch (_deleteUpdateFromCache_clientMgmt(cEntry, clientID))
  {
    case -1 : // Not found
      LOG(LEVEL_INFO, "Delete aborted, update [0x%08X] not referenced to the "
                      "client (0x%20X)!", cEntry->updateID, clientID);
      retVal = false;
      break;
    case 0 : // no reference left
      setGCFlag(cEntry, timeOfDeletion);
    case 1 : // still some left, don't delete
    default:
      retVal = true;
  }

  return retVal;
}

/**
 * Removes the update data from the list and releases all memory associated to
 * it. Also, if this update contains bgpsec blob, it will remove this
 * update from the SKI Cache.
 *
 * @note This method ONLY deletes the update from the update cache. It is
 *       important to assure that other references such as the prefix_cache
 *       might be affected by this.
 *
 * @param self The instance of the update cache
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 *                 If this id is zero all mappings and the update itself will be
 *                 removed!
 * @param updateID The ID of the update that has to be removed.
 * @param keepTime A proposed time in seconds the update should still be kept
 *                 before final deletion. The cache might remove the update at
 *                 any time though.
 *
 * @return true If the update / association could be removed, false if the
 *              update was not either found in the cache or no association to
 *              the client was found.
 */
bool deleteUpdateFromCache(UpdateCache* self, uint8_t clientID,
                           SRxUpdateID* updateID, uint16_t keepTime)
{
  CacheEntry* cEntry;
  bool retVal = false;
  // This seems to be silly at this point but it might be that the id will
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;
  if (keepTime < self->sysConfig->defaultKeepWindow)
  {
    keepTime = self->sysConfig->defaultKeepWindow;
  }
  uint16_t timeToBeDeleted = getGCTime(keepTime);

  // Get the update cache entry from the update cache.
  if (tableFind(self, updID, &cEntry))
  {
    retVal = _deleteUpdateFromCache(self, clientID, cEntry, timeToBeDeleted);
    if (retVal && (cEntry->pathData.bgpsec_path != NULL))
    {
      // Unregister the update from the SKI CACHE.
      SKI_CACHE* sCache = getSKICache();
      UC_UpdateData* data = &cEntry->pathData;
      if (!ski_unregisterUpdate(sCache, updateID, data->bgpsec_path))
      {
        LOG(LEVEL_WARNING, "Could not unregister update [0x%08X] from the ski "
                           "cache!", updID);
      }
    }
  }
  else
  {
    LOG(LEVEL_INFO, "Delete aborted, update [0x%08X] not found!", updID);
  }

  return retVal;
}

/**
 * This function returns the update signature if already existent. It will NOT
 * start the signing. If no signature exists the return value is NULL
 *
 * @param self The instance of the update cache
 * @param result The result of the function call.
 * @param updateID The id of the update
 * @param prependCount the prepend count of the host AS
 * @param peerAS The peer AS
 * @param algorithm The algorithm used
 * @param complete Indicates if the complete signature block or just the
 *                 new addition will be returned.
 * @return The signature block.
 */
UpdSigResult* getUpdateSignature(UpdateCache* self, UpdSigResult* result,
                                 SRxUpdateID* updateID, uint32_t prependCount,
                                 uint32_t peerAS, uint16_t algorithm,
                                 bool complete)
{
  ////////////////////////////////////////////////////////////////////////////// TOUCHED( ); OK ( ); NOT YET (x)
  CacheEntry* cEntry;
  // This seems to be silly at this point but it might be that the id will
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;


  // Currently we do NOT support any algorithm!
  RAISE_ERROR("UPDATE SIGNATURES ARE CURRENTLY NOT SUPPORTED!");

  // Currently we by default throw an algorithm not supported error.
  // This can be overwritten by update not found. Once signing is supported
  // this will be changed.
  result->containsError   = true;
  result->errorCode       = SRXERR_ALGO_NOT_SUPPORTED;
  result->signatureLength = 0;
  result->signatureBlock  = NULL;

  // Look for the update
  if (!tableFind(self, updID, &cEntry))
  {
    LOG(LEVEL_INFO, "Update [0x%08X] not found! Can not sign it!", updID);
    result->errorCode = SRXERR_UPDATE_NOT_FOUND;
  }

  return result;
}

/**
 * This method is not for usage within the update cache management. It is
 * mainly to allow the server console to query for update information.
 *
 * @param self The update cache
 * @param statistics The statistics information to be filles. The value
 *                   updateID MUST be set and will be used to locate the update.
 *
 * @return true if the update was found, otherwise false
 */
bool getUpdateStats(UpdateCache* self, UC_UpdateStatistics* statistics)
{
  CacheEntry* cEntry;
  bool retVal = false;

  if (statistics == NULL)
  {
    RAISE_SYS_ERROR("The given statistics block is NULL!");
  }
  else if (*statistics->updateID == 0)
  {
    RAISE_SYS_ERROR("The given updaetID is 0 (INVALID ID)!");
  }
  // Look for the update
  else if (tableFind(self, *statistics->updateID, &cEntry))
  {
    retVal = true;
    statistics->asn                           = cEntry->asn;
    cpyPrefix(&statistics->prefix, &cEntry->prefix);
    statistics->bgpsecResult.containsError    = false;
    statistics->bgpsecResult.errorCode        = 0;
    statistics->bgpsecResult.signatureBlock   = NULL;
    statistics->bgpsecResult.signatureLength  = 0;
    statistics->defResult.resSourceROA   =cEntry->defaultResult.resSourceROA;
    statistics->defResult.resSourceBGPSEC=cEntry->defaultResult.resSourceBGPSEC;
    statistics->defResult.result.roaResult =
                                         cEntry->defaultResult.result.roaResult;
    statistics->defResult.result.bgpsecResult =
                                      cEntry->defaultResult.result.bgpsecResult;
    statistics->result.roaResult    = cEntry->srxResult.roaResult;
    statistics->result.bgpsecResult = cEntry->srxResult.bgpsecResult;
    statistics->roa_count           = cEntry->roaRefCount;
  }
  return retVal;
}

/**
 * Return the cache internal copy of the update data.
 *
 * @param self The update cache
 * @param updateID The ID of the update
 *
 * @return the pointer to the internal stored bgp update data
 *
 * @since 0.5.0.0
 */
UC_UpdateData* getUpdateData(UpdateCache* self, SRxUpdateID* updateID)
{
  CacheEntry* cEntry = NULL;
  UC_UpdateData* data = NULL;
  SCA_BGP_PathAttribute* bgpsec_path = NULL;

  // Look for the update
  if (tableFind(self, *updateID, &cEntry))
  {
    data = &cEntry->pathData;
    bgpsec_path = data->bgpsec_path;
  }

  return data;
}

/**
 * Empties a cache and releases all memory attached to each of the elements.
 *
 * @note Primarily for development purposes or program shutdown.
 *
 * @param self Instance of the update cache.
 */
void emptyUpdateCache(UpdateCache* self)
{
  ////////////////////////////////////////////////////////////////////////////// TOUCHED(X); OK ( ); NOT YET ( ); Tested ( )
  acquireWriteLock(&self->tableLock);
  lockMutex(&self->itemMutex);
  emptySList(&self->allItems);
  SKI_CACHE* sCache = getSKICache();
  // clean all updates from the update cache.
  ski_clean(sCache, SKI_CLEAN_UPDATES);
  unlockMutex(&self->itemMutex);

  self->table     = NULL;
  self->itemsUsed = NUM_PREALLOC;

  unlockWriteLock(&self->tableLock);
}


/**
 * This method is used to configure the update cache in such that the minimum
 * number of clients expected per update can be configured. the value MUST not
 * be zero, zero values are reset to be one. This function does not change
 * already created updates in the cache. They will be extended on an as needed
 * basis.
 *
 * @param self the UpdateCache instance.
 * @param noClients The minimum number of clients expected per update.
 */
void setMinClients(UpdateCache* self, uint8_t noClients)
{
  self->minNumberOfClients = noClients;
}

/**
 * Fill the given array "clientIDs" with the number clientID's associated to the
 * update with the "updateID". This method will NOT initialize the given array
 * with zero's but will fill the array without "holes". The return value is the
 * number of clientIDs filles in the array or -1 if the array is to small!
 *
 * @param self The updateCache.
 * @param updateID pointer to the update ID.
 * @param clientIDs an initialized array of uint8_t elements.
 * @param size Size of the provided array in bytes.
 *
 * @return the number of arrays filled in the array, -1 if the array is to
 *         small.
 *
 * @since 0.3.0
 */
int getClientIDsOfUpdate(UpdateCache* self, SRxUpdateID* updateID,
                         uint8_t* clientIDs, uint8_t size)
{
  // The cache entry also need the addition of source and predefined result.
  CacheEntry* cEntry = NULL;
  int retVal = 0;
  int idx = 0;

  // Look for the update
  if (tableFind(self, *updateID, &cEntry))
  {
    if (cEntry->noPossibleClients <= size)
    {
      // Run through the list of clients and fill them in the provided
      // array
      for (idx = 0; idx < cEntry->noPossibleClients; idx++)
      {
        if (cEntry->clients[idx] != 0)
        {
          clientIDs[retVal++] = cEntry->clients[idx];
        }
      }
    }
    else
    {
      retVal = -1;
    }
  }

  return retVal;
}

/**
 * Removed the association of the client to all updates within the cache.
 *
 * @param self The update cache
 * @param clientID The client ID
 * @param clientMapping must be NULL for clientID == 0, otherwise not.
 * @param keepTime the keep time.
 *
 * @return the number of update associations removed, -1 if an error occured.
 *
 * @since 0.3.0
 */
int unregisterClientID(UpdateCache* self, uint8_t clientID, void* clientMapping,
                       uint32_t keepTime)
{
  int idsRemoved = -1;
  SListNode*  lNode;
  CacheEntry* cEntry;
  ProxyClientMapping* mapping = (ProxyClientMapping*)clientMapping;

  acquireWriteLock(&self->tableLock);
  lockMutex(&self->itemMutex);
  if (!self->lockedClients[clientID])
  {
    idsRemoved = 0;
    self->lockedClients[clientID]=true;
    FOREACH_SLIST(&self->allItems, lNode)
    {
      cEntry = (CacheEntry*)lNode->data;
      if (cEntry != NULL)
      {
        if (_deleteUpdateFromCache(self, clientID, cEntry, keepTime))
        {
          idsRemoved++;
          mapping->updateCount--;
        }
      }
      if (mapping->updateCount == 0)
      {
        break;
      }
    }
    self->lockedClients[clientID]=false;
  }
  else
  {
    LOG(LEVEL_ERROR, "Attempt to unregister clocked client[0x%02X] from update "
                     "cache!", clientID);

  }
  unlockMutex(&self->itemMutex);
  unlockWriteLock(&self->tableLock);

  return idsRemoved;
}

/**
 * This method determines if an update with the given ID already exist. If so,
 * a collision is detected. A collision is detected if an update with the same
 * updateID already exist but the data is different.
 *
 * @param self The Update cache
 * @param updateID Update ID to be checked!
 * @param prefix the prefix of the update
 * @param asn the Origin AS of the update
 * @param dataLength The length of the bgpsec blob
 * @param data The bgpsec data blob.
 *
 * @return true if a collision could be detected!
 */
bool detectCollision(UpdateCache* self, SRxUpdateID* updateID, IPPrefix* prefix,
                     uint32_t asn, BGPSecData* bgpsecData)
{
  CacheEntry* cEntry;
  UC_UpdateData* data;
  bool collision = false;

  // Generic usage for all data buffers
  int length = 0;

  // Try to find the update itself.
  if (tableFind(self, *updateID, &cEntry))
  {
    data = &cEntry->pathData;

    // An update was found, now declare collision until it is determined that
    // the update found is the same as the update requested.
    collision = true;
    if (cEntry->asn == asn)
    {
      if (data->hops == bgpsecData->numberHops)
      {
        // Now check the ip prefix first, then the data blob
        int  idx = 0;
        int  bytes = (cEntry->prefix.ip.version == 4) ? 4  : 16;
        // collision will be set true as soon as a collision is found.
        collision = false;
        while (!collision && idx < bytes)
        {
          // 1. 4 bytes of v4 and v6 overlap
          collision = (        prefix->ip.addr.v6.u8[bytes] !=
                       cEntry->prefix.ip.addr.v6.u8[bytes]);
          idx++;
        }

        idx = 0;
        // Now check the BGP4 path - only if  not already collided
        length = data->hops * 4;
        u_int8_t* d1 = (u_int8_t*)data->asn_path;
        u_int8_t* d2 = (u_int8_t*)bgpsecData->asPath;
        collision = memcmp(d1, d2, length);

        // Now check the BGPsec_PATH
        if (!collision)
        {
          u_int8_t* d1 = (u_int8_t*)data->bgpsec_path;
          u_int8_t* d2 = bgpsecData->bgpsec_path_attr;
          collision = memcmp(d1, d2, data->length);
        }
      }
    }
  }

  return collision;
}

////////////////////////////////////////////////////////////////////////////////
// Other Helper Functions
////////////////////////////////////////////////////////////////////////////////

/**
 * Returns a textual representation of a given IPPrefix.
 * @param prefix The IPPrefix.
 *
 * @return The text (human readable) version of the prefix.
 *
 * @note Local, static buffer - i.e. not thread-safe!
 */
const char* ipToStr(IPAddress* ip)
{
  #define BUF_SIZE  MAX_IP_V6_STR_LEN
  static const char buf[BUF_SIZE];

  return (ip->version == 4)
           ? ipV4AddressToStr((IPv4Address*)&ip->addr.v4, (char*)buf, BUF_SIZE)
           : ipV6AddressToStr((IPv6Address*)&ip->addr.v6, (char*)buf, BUF_SIZE);
}

////////////////////////////////////////////////////////////////////////////////
//  Print Functions
////////////////////////////////////////////////////////////////////////////////

/**
 * print the srx validation result for the particular attribute.
 *
 * @param out The xml stream
 * @param attrName the attribute name.
 * @param result The validation result of type SRxValidationResultVal
 * @param hasNotFound the validation state NOTFOUND is accepted!
 *
 * @return true if the validation state was accepted, otherwise false.
 *
 * @since 0.3.0
 *
 */
bool printXMLValResult(XMLOut* out, const char* attrName,
                       SRxValidationResultVal result, bool hasNotFound)
{
  bool retVal = true;
  switch (result)
  {
    case SRx_RESULT_DONOTUSE :
              addStrAttrib(out, attrName, "DO NOT USE!");
              break;
    case SRx_RESULT_UNDEFINED :
              addStrAttrib(out, attrName, "UNDEFINED!");
              break;
    case SRx_RESULT_VALID :
              addStrAttrib(out, attrName, "VALID!");
              break;
    case SRx_RESULT_INVALID :
              addStrAttrib(out, attrName, "INVALID!");
              break;
    case SRx_RESULT_NOTFOUND :
              if (hasNotFound)
              {
                addStrAttrib(out, attrName, "NOTFOUND!");
                break;
              }
    default:
              addStrAttrib(out, attrName, "?????????");
              retVal = false;
              break;
  }

  return retVal;
}

/**
 * Print the content of the update cache to the given file.
 *
 * @param self the update cache
 * @param stream The file to be written into.
 * @param maxBlob The maximum number of blob bytes printed. (-1 all, 0 none,
 *                >0 the specified number or the blob length if less.)
 *
 * @since 0.3.0
 *
 */
void outputUpdateCacheAsXML(UpdateCache* self, FILE* stream, int maxBlob)
{
#define CLIENT_LIST_STRING_LEN 1024
  XMLOut      out;
  SListNode*  updateListNode;
  CacheEntry* update;
  uint8_t     clIdx;
  uint8_t     noClients;
  char        clientString[CLIENT_LIST_STRING_LEN];
  memset(clientString, '\0', CLIENT_LIST_STRING_LEN);
  char*       strPtr = NULL;
  initXMLOut(&out, stream);
  openTag(&out, "update-cache");

  // Add the current gc time
  addU32Attrib(&out, "current-gc-time", getGCTime(0));

  // Updates
  if (sizeOfSList(&self->allItems))
  {
    openTag(&out, "updates");
    FOREACH_SLIST(&self->allItems, updateListNode)
    {
      update = (CacheEntry*)getDataOfSListNode(updateListNode);
      openTag(&out, "update");
        addH32Attrib(&out, "update-id", update->updateID);
        // noClients contains the number of clients used during the last run.
        // the multiplicator "4" is used for the maximum space used for any
        // client ID (3 char + comma)
        memset(clientString, '\0', noClients*4);
        noClients = 0;
        strPtr = clientString;
        for(clIdx = 0; clIdx < update->noPossibleClients; clIdx++)
        {
          if (update->clients[clIdx] != 0)
          {
            noClients++;
            if (noClients == 1)
            {
              strPtr += sprintf(strPtr, "%u", update->clients[clIdx]);
            }
            else
            {
              strPtr += sprintf(strPtr, ",%u", update->clients[clIdx]);
            }
          }
        }
        addU32Attrib(&out, "no-clients", noClients);
        if (noClients > 0)
        {
          addStrAttrib(&out, "client-list", clientString);
        }
        addU32Attrib(&out, "gc", update->gcFlag);
        addU32Attrib(&out, "origin-as", update->asn);
        addAttrib(&out, "prefix", "%s/%u",
                  ipToStr(&update->prefix.ip),
                  update->prefix.length);
        addIntAttrib(&out, "roa-count", update->roaRefCount);
        if (!printXMLValResult(&out, "origin-val",
                               update->srxResult.roaResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid origin validation state %d",
                      update->updateID, update->srxResult.roaResult);
        }
        if (!printXMLValResult(&out, "path-val", update->srxResult.bgpsecResult,
                               false))
        {
          RAISE_ERROR("Update[0%x08X] with invalid path validation state %d",
                      update->updateID, update->srxResult.bgpsecResult);
        }
        if (!printXMLValResult(&out, "def-origin-val",
                               update->defaultResult.result.roaResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid default origin validation "
                      "state %d", update->updateID,
                      update->defaultResult.result.roaResult);
        }
        if (!printXMLValResult(&out, "def-path-val",
                               update->defaultResult.result.bgpsecResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid default path validation "
                      "state %d", update->updateID,
                      update->defaultResult.result.bgpsecResult);
        }
        addIntAttrib(&out, "hops", update->pathData.hops);
        addIntAttrib(&out, "bgpsec-len", update->pathData.length);
      closeTag(&out);
    }
    closeTag(&out);
  }

  closeTag(&out);
  releaseXMLOut(&out);
}



void process_ASPA_EndOfData(UpdateCache* self, 
                            int (*cb)(void* uCache, void* hldr, uint32_t uid, uint32_t pid, time_t ct), 
                            void* rpkiHandler)
{
  time_t lastEndOfDataTime = time(NULL);
  int count=0;
  CacheEntry* cEntry, *tmp;
    
  LOG(LEVEL_DEBUG, "Last end of Data Time: %u", lastEndOfDataTime);
  HASH_ITER(hh, (CacheEntry*)self->table, cEntry, tmp) 
  {
    LOG(LEVEL_DEBUG, "[%d] updateID: 0x%08X  pathID: 0x%08X", 
        count++, cEntry->updateID, cEntry->aspathCacheID);

    cb((void*)self, (void*)rpkiHandler, cEntry->updateID, cEntry->aspathCacheID, 
        lastEndOfDataTime); // call process_ASPA_EndOfData_main
  }

}
